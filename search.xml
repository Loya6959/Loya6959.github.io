<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>让你更加专注于写作——Markdown简单教学</title>
    <url>/2024/01/11/Markdown%E7%AE%80%E5%8D%95%E6%95%99%E5%AD%A6/</url>
    <content><![CDATA[<p>作为一名学习数媒专业的学生，对我来说排版并不算什么难事，但有时我也不想在排版美化上花太多时间，并且也有很多不是设计类专业的人也需要一个无需过多设计就能达到不错视觉效果，或者说可读性的文档。现在的一个通用解决方式便是Markdown，这个轻量标记语言确实挺好用，包括这篇博客也是拿它进行攥写的。</p>
<p>接下来就正式进入内容。</p>
<h2 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h2><p>Markdown的语法整体是比较简单的，学习md（Markdown的缩写）应该花不了多少时间。所以这里就先介绍一些简单的语法吧。</p>
<p>针对本博客内语法的展示，除了使用博客本身的渲染效果外，通过截图展示的渲染效果均使用<a href="https://typoraio.cn/">Typora</a>的Github主题。各位在学习或者编写Markdown时也可以用自己喜欢的Markdown编辑器。</p>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>在正式开始语法介绍前，我们得清楚Markdown（之后简称md）的文件类型。md作为一个轻量标记语言，它的文件格式为<code>.md</code>，这个文件本质上就是一个文本文件，因此如果愿意，直接拿<code>.txt</code>编写md也是完全没问题的。</p>
<p>md的效果渲染主要依靠市面上的各种md编辑器、渲染器完成，因此md在不同渲染器的渲染效果可能会有所不同。</p>
<h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>md里边最简单的语法实际上是段落，它的写法如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">所以，这就是段落。</span><br><span class="line"></span><br><span class="line">Ok，这是另一个段落</span><br></pre></td></tr></table></figure>

<p>在这篇博客内看到的所有正文（包括这一段），都是使用的相同语法，所以这里我就不放图片展示了。</p>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>一篇文章，一篇博客总是少不了标题的，而在md中，标题的语法非常简单，我们先来看一级标题：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br></pre></td></tr></table></figure>

<p>那么二级标题、三级标题甚至往后呢？</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="section">###### 六级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">####### 七级标题（并不支持）</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/01/11/Markdown%E7%AE%80%E5%8D%95%E6%95%99%E5%AD%A6/%E6%A0%87%E9%A2%98.png" alt="标题"></p>
<p><code>#</code>的数量能够决定标题的级数，md支持编写者定义1~6级标题，标题从1级到6级的字体大小逐级递减。一般来说，我们只会用到其中的1~4级标题，但是由于博客的特殊性，一级标题在博客攥写时一般也不使用，因此在博客下常用的就是2~4级标题了（这只是个人拙见）。</p>
<h3 id="图片和链接"><a href="#图片和链接" class="headerlink" title="图片和链接"></a>图片和链接</h3><p>图片和链接二者虽然并不相同，但在md中，它们的语法却颇为相似，我们先来看看二者的语法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">这是一个链接</span>](<span class="link">https://www.bilibili.com</span>)</span><br><span class="line">![<span class="string">这是一张图像</span>](<span class="link">D:\桌面文件\物理超度.jpg</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/01/11/Markdown%E7%AE%80%E5%8D%95%E6%95%99%E5%AD%A6/%E5%9B%BE%E5%83%8F%E5%92%8C%E9%93%BE%E6%8E%A5.png" alt="图片和链接"></p>
<p>可以发现，二者语法只是相差了一个半角叹号<code>!</code>，但是实现的效果却截然不同。当然，这里图片的路径我使用的绝对路径，实际上我们也可以使用相对路径和链接来引用图片。现在，我们假设在桌面的test文件夹下有如下内容:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/text</span><br><span class="line">    - test.md</span><br><span class="line">    - /img</span><br><span class="line">        test.png</span><br></pre></td></tr></table></figure>

<p>我们要做的，就是将img下的图像用相对路径和绝对路径两种方式进行引用，然后在网络上随便找个图像链接，作为我们的第三个示例：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">相对路径</span>](<span class="link">./img/test.png</span>)</span><br><span class="line">![<span class="string">绝对路径</span>](<span class="link">C:\Users\loya\Desktop\test\img\test.png</span>)</span><br><span class="line">![<span class="string">网络链接</span>](<span class="link">https://www.bilibili.com/favicon.ico</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/01/11/Markdown%E7%AE%80%E5%8D%95%E6%95%99%E5%AD%A6/%E5%9B%BE%E5%83%8F%E7%9A%84%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F.png" alt="图片的引用方式"></p>
<p>可以发现，我们先是分别用相对路径和绝对路径引用了同一张图片，然后我们再在网络上找到了B站的Icon链接并进行了引用。在二者语法中<code>[]</code>内都是填写一个任意文本，图片引用语法中，<code>[]</code>内的文本会在图片丢失时显示，而链接语法中的<code>[]</code><br>则是链接的文本。<code>()</code>内的内容都是其引用（指向）的地址，这里的地址都能使用上述提到的三种地址</p>
<p>此外，二者还可以指定鼠标悬停到其上后的标题文本，就像这样：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">试试悬停？</span>](<span class="link">&quot;&quot; &quot;悬停试试！&quot;</span>)</span><br><span class="line">![<span class="string">试试悬停</span>](<span class="link">&quot;&quot; &quot;悬停试试！&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>来看看效果（将鼠标放在其上试试，这里顺带展示了图片丢失时图片语法的情况）：<br><a href="https://" title="悬停试试！">试试悬停？</a><br><img src="/%22%22" alt="试试悬停" title="悬停试试！"></p>
<p>总结起来，它们的语法模板就是这样的：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Text</span>](<span class="link">Link &quot;Title&quot;</span>)</span><br><span class="line">![<span class="string">Text</span>](<span class="link">Link &quot;Title&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>Text</code>：链接的文本，图片的Alt文本</li>
<li><code>Link</code>：链接或图片的地址（可以是本地绝对路径、相对路径，以及网络链接）</li>
<li><code>Title</code>：鼠标悬停时显示的标题文本</li>
</ul>
<p>不过各位也许有发现，图片的语法并不支持指定图片的尺寸，这可是个头疼的问题，毕竟有时我们可是会引用一些尺寸稍大的文件的。幸运的是，md实际上也能支持一些HTML标签，<code>&lt;img/&gt;</code>就在其支持的范围之内：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;path&quot;</span> <span class="attr">width</span>=<span class="string">&quot;[num][dw]&quot;</span> <span class="attr">height</span>=<span class="string">&quot;[num][dw]&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;text&quot;</span> <span class="attr">title</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>在md中使用<code>&lt;img/&gt;</code>就像在HTML中使用它的方式一样，不过正常情况下并不推荐在md中使用HTML标签就是了。</p>
<h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>有时，我们需要让阅读者注意到特定的关键词，或者往正文文本中插入单句代码。md贴心的为我们提供了如下的语法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br><span class="line"><span class="strong">**粗体**</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体*</span>**</span>（一些md渲染器并不能很好的同时显示粗斜体，也可能是使用的字体的问题）</span><br><span class="line">~~删除线~~</span><br><span class="line"><span class="code">`单句代码`</span></span><br><span class="line">==底部着色==（一些md渲染器并不支持此语法）</span><br></pre></td></tr></table></figure>

<p><img src="/2024/01/11/Markdown%E7%AE%80%E5%8D%95%E6%95%99%E5%AD%A6/%E5%BC%BA%E8%B0%83.png" alt="强调"></p>
<p>当然，就像展示的那样，一些md并不能很好的支持<code>==cont==</code>底部着色，还有<code>***cont***</code>粗斜体，因此实际使用这些语法时得了解所使用的md渲染器到底支不支持它们。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用一些文献、他人的博客选段总是在所难免的，如果需要让读者清楚某段文本是引用文本，那该怎么办呢？</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 引用文本</span></span><br></pre></td></tr></table></figure>

<p>渲染效果如下（不同的md渲染器可能会有所不同，这里我就偷懒用博客自己的渲染方案了）：</p>
<blockquote>
<p>引用文本</p>
</blockquote>
<p>看着是不是特别醒目？还没完，这个语法可以支持多个段落，甚至还能嵌套：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 引用文本1</span></span><br><span class="line"><span class="quote">&gt; 引用文本2</span></span><br><span class="line"><span class="quote">&gt; 引用文本3</span></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 引用文本1</span></span><br><span class="line"><span class="quote">&gt; &gt; 引用文本2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用文本1<br>引用文本2<br>引用文本3</p>
</blockquote>
<p>下面是引用嵌套：</p>
<blockquote>
<p>引用文本1</p>
<blockquote>
<p>引用文本2</p>
</blockquote>
</blockquote>
<p>当然，引用块多了似乎也不是太好，影响观感不说，要是被认为通篇都是引用，那还不如转载算了对吧。</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表可是个好东西，能够将散乱的信息进行整合。信息整合总归得区分其是否需要关心顺序逻辑，因此md提供了两种列表的语法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 无序列表1</span><br><span class="line"><span class="bullet">-</span> 无序列表2</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 有序列表1</span><br><span class="line"><span class="bullet">2.</span> 有序列表2</span><br></pre></td></tr></table></figure>

<ul>
<li>无序列表1</li>
<li>无序列表2</li>
</ul>
<ol>
<li>有序列表1</li>
<li>有序列表2</li>
</ol>
<p>无序列表除了可以使用<code>-</code>开头，用<code>*</code>、<code>+</code>也是没问题的。有序列表以连续的有序列表定义中的第一个的数字开始，例如下面的有序列表中，第一个的序号为2，第二个同样是2：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">2.</span> 有序列表1</span><br><span class="line"><span class="bullet">2.</span> 有序列表2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>有序列表1</li>
<li>有序列表2</li>
</ol>
<p>可以发现，至少在这篇博客中，序号是从2开始依次增加的，即便我为二者给定的序号都是相同的。不过在实际攥写时，并不推荐如此攥写，渲染器虽然能够帮我们解决问题，但是自己改的时候恐怕会一头雾水。由于md可以使用普通的文本编辑器查看编辑，因此像上面的有序列表写法也会给这类读者造成困扰。</p>
<p>此外，无序列表、有序列表和引用一样，都能支持嵌套：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">+</span> 一级</span><br><span class="line"><span class="bullet">  +</span> 二级</span><br><span class="line"><span class="bullet">    +</span> 三级</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 一级</span><br><span class="line"><span class="bullet">    1.</span> 二级</span><br></pre></td></tr></table></figure>

<ul>
<li>一级<ul>
<li>二级<ul>
<li>三级</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>一级<ol>
<li>二级</li>
</ol>
</li>
</ol>
<p>无序列表在嵌套时，渲染器会为其使用不同的项目符号，并且进行缩进，我这里使用的两个空格缩进（有序列表用的四个空格）。请注意，嵌套时同一级别必须使用相同的缩进量，不然渲染器很可能将不同缩进量的列表当作不同的级别。</p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>刚刚其实我们已经使用了单句代码的语法，也就是使用一对<code>&acute;</code>进行包裹，不过难免我们会在这个语法当中使用这个符号本身，就像现在这样。我这里的解决方法是使用的<code>&lt;code&gt;&lt;/code&gt;</code>标签包裹反引号的HTML字符代码<code>&amp;acute;</code>，保证博客不对这段文本进行错误渲染。当然，如果其中有包括正常文本，其实也有更简单的方法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">``正常显示反引号`</span>code<span class="code">`其实很简单`</span>。``</span><br></pre></td></tr></table></figure>

<p><code>正常显示反引号`code`其实很简单`。</code></p>
<p>单句代码的语法可以使用两个反引号包裹，实现在内部正常显示反引号字符。当然，处于末尾的反引号字符同样有可能会被错误渲染，因此我在其后又加了一个句号，这才保证其正常显示。</p>
<p>那么……代码块又该怎么写呢？</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">import this</span><br><span class="line">print(&quot;Hello, world!&quot;)</span><br></pre></td></tr></table></figure>

<pre><code>import this
print(&quot;Hello, world!&quot;)
</code></pre>
<p>将段落缩进四个空格就能将一块段落渲染为代码块，不过这种缩进并不是那么让人喜欢，毕竟它在文本编辑时会影响阅读体验，因此我们实际上更常用的是不缩进的代码块语法（围栏式）：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">-<span class="code">```Python</span></span><br><span class="line"><span class="code">import this</span></span><br><span class="line"><span class="code">print(&quot;Hello, world!&quot;)</span></span><br><span class="line"><span class="code">```</span>-</span><br><span class="line"> (这里为了渲染器不错误渲染这个代码块，特意在前后加了-，实际编写时请不要额外添加符号)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> this</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用成对的三个反引号包裹文本，便能将其间的文本声明为代码块。而在首行的三个反引号后，还可以指定代码块的编程语言（例如我在这里使用的Python）。md渲染器会根据代码块的语言类型，来针对不同的编程语言进行着色（着色效果因渲染器而异）。</p>
<p>技术类博客会大量使用这种代码块语法（例如这个博客），因此这个语法还是挺重要的对吧？</p>
<h3 id="分割线与转义字符"><a href="#分割线与转义字符" class="headerlink" title="分割线与转义字符"></a>分割线与转义字符</h3><p>在一些情况下，我们可能会面临不使用标题但又需要明显分割文段的尴尬情况，在HTML里面，<code>&lt;hr /&gt;</code>来声明一根分割线，这在md中也有对应的语法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">***</span></span><br><span class="line"><span class="strong">__<span class="emphasis">_</span></span></span><br></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
<p>连续使用三个以上的<code>-</code>、<code>*</code>或<code>_</code>便能声明一根分割线，上面的三个分割线就是这么来的。当然，如果各位愿意，用<code>&lt;hr /&gt;</code>也是没问题的，虽然我并不推荐使用它。</p>
<p>与此同时，从刚刚开始各位应该可以发现一件事，就是我在担心博客的渲染问题，这实际上就是在使用特殊符号时的一种担心。md中可以使用反斜线<code>\</code>来对特殊字符进行转义：</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\</td>
<td align="center">反斜线</td>
</tr>
<tr>
<td align="center">`</td>
<td align="center">反引号</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">星号</td>
</tr>
<tr>
<td align="center">_</td>
<td align="center">下划线</td>
</tr>
<tr>
<td align="center">{}</td>
<td align="center">花括号</td>
</tr>
<tr>
<td align="center">[]</td>
<td align="center">方括号</td>
</tr>
<tr>
<td align="center">()</td>
<td align="center">圆括号</td>
</tr>
<tr>
<td align="center">#</td>
<td align="center">井号</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">加号</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">减号</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">点</td>
</tr>
<tr>
<td align="center">!</td>
<td align="center">感叹号（半角）</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">竖线</td>
</tr>
</tbody></table>
<p>除了转义，我们还会遇到使用特殊符号的情况，这时我们可以使用HTML字符代码来表示特定字符。这里就不用列表来详细罗列了，感兴趣的各位可以在互联网上搜索。</p>
<h2 id="Markdown拓展语法"><a href="#Markdown拓展语法" class="headerlink" title="Markdown拓展语法"></a>Markdown拓展语法</h2><p>现在，我们就可以来学习一下高阶的东西了，当然实际上刚刚也说了一些高级语法，当然，我觉得无伤大雅。我们主要介绍这些：</p>
<ul>
<li>表格</li>
<li>脚注</li>
<li>任务列表</li>
<li>定义列表</li>
</ul>
<p>这四个也算是比较常用的了。</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>在上面，我们就已经见识过md的表格了，现在我们来定义一个新的表格试试水：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| HEAD1 | HEAD2 | HEAD3 |</span><br><span class="line">|  ---  |  ---  |  ---  |</span><br><span class="line">| CONT1 | <span class="code">`CONT2`</span> | <span class="strong">**CONT3**</span> |</span><br><span class="line">| <span class="emphasis">*CONT1*</span> | CONT2 | CONT3 |</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>HEAD1</th>
<th>HEAD2</th>
<th>HEAD3</th>
</tr>
</thead>
<tbody><tr>
<td>CONT1</td>
<td><code>CONT2</code></td>
<td><strong>CONT3</strong></td>
</tr>
<tr>
<td><em>CONT1</em></td>
<td>CONT2</td>
<td>CONT3</td>
</tr>
</tbody></table>
<p>表格语法的第一行是定义表格的表头，表头一般情况下会被md渲染器进行字体加粗、背景色加重的着重渲染，并且表头内的文本是居中的。而在第二行，看起来就像是在分割表头和表格的内容，而在第三行以及之后，我们又开始使用第一行的写法了，但是渲染出的样式却与表头完全不同。</p>
<p>还有一个细节，那就是实际上我们在表格中使用了简单的md的其他语法，这里使用的强调语法，而实际上，表格里面也只能使用强调语法。</p>
<p>不过，我们有时也需要处理表格内单元格对齐的问题，这个在md里也能简单处理：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| HEAD1 | HEAD2 | HEAD3 |</span><br><span class="line">|  :---  |  :---:  |  ---:  |</span><br><span class="line">| <span class="emphasis">*LEFT*</span> | <span class="code">`CENTER`</span> | <span class="strong">**RIGHT**</span> |</span><br><span class="line">| <span class="emphasis">*LEFT*</span> | <span class="code">`CENTER`</span> | <span class="strong">**RIGHT**</span> |</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">HEAD1</th>
<th align="center">HEAD2</th>
<th align="right">HEAD3</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>LEFT</em></td>
<td align="center"><code>CENTER</code></td>
<td align="right"><strong>RIGHT</strong></td>
</tr>
<tr>
<td align="left"><em>LEFT</em></td>
<td align="center"><code>CENTER</code></td>
<td align="right"><strong>RIGHT</strong></td>
</tr>
</tbody></table>
<p>可以发现，我们在第二行的对应单元格中<code>---</code>的前后加上了<code>:</code>，从而达到了不同的对齐效果，但是正如我们所见，这个对齐改变的是所在列的所有单元格的对齐方式（包括表头）。我个人在实际使用表格时，只会使用居中对齐，而各位如何使用就看各位自己的想法和心情了。</p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>我们经常可以在一些论文文献中见到某个词上带有[1]上标的这种情况，这就是我们说的脚注。脚注通常都会在文末进行详细解释，或者指出其引用的其他文献、做注释等。在md中也可以定义脚注，就像这样：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">BiliBili[^1]</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">https://www.bilibili.com/</span></span><br></pre></td></tr></table></figure>

<p>BiliBili<a href="https://www.bilibili.com/">^1</a></p>
<p>…</p>
<p>大部分md渲染器并不会渲染<code>[^1]: https://www.bilibili.com/</code>这个部分，而这个部分也不会被显示，它的<code>:</code>后面的文本可以是这里的链接，也可以是一段文本，不过我的这个博客框架似乎会将脚注<code>[^1]</code>渲染为指向<code>[^1]: https://www.bilibili.com/</code>冒号后内容的超链接，因此我这里就索性直接用的链接。</p>
<p>就我个人来说，实际上我基本就没用过脚注，在现在所使用的博客框架肯定更是不会用它了，因为同样的功能完全可以用上面提到的链接语法实现。不过这个也仁者见仁智者见智，对吧。</p>
<h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>任务列表，我个人其实更喜欢叫它清单，这个列表在md中的定义就像定义无序列表一样简单：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> [ ] 任务1</span><br><span class="line"><span class="bullet">-</span> [x] 任务2</span><br></pre></td></tr></table></figure>

<ul>
<li><input disabled="" type="checkbox"> 任务1</li>
<li><input checked="" disabled="" type="checkbox"> 任务2</li>
</ul>
<p>这个语法简单来说就是在无序列表的基础上，在后面加上了一对<code>[ ]</code>，请注意，<strong>括号内必须有个空格占位</strong>，这样才能表示一个空的多选框。而想表示复选框被选中就换成<code>[x]</code>。<code>[ ]</code>和<code>[x]</code>与<code>-</code>之间也需要用空格隔开，不然这个语法同样不会生效。</p>
<p>这个语法我在别人的博客倒是有见到过不少次，但我自己基本上只在本地使用，Typora在定义这个后，可以很方便的选中&#x2F;取消选中复选框，因此拿来当作本地的清单还是挺推荐的。</p>
<h3 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h3><p>定义列表一般情况下用来解释一些术语，而在一些md渲染器中也是支持的，语法如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">络亚</span><br><span class="line">: 这就是我！不是什么术语！</span><br><span class="line">: 拿自己做例子还挺好玩的（不是）</span><br></pre></td></tr></table></figure>

<dl><dt>络亚<br>: 这就是我！不是什么术语！</dt><dd>拿自己做例子还挺好玩的（不是）</dd></dl><p>似乎在我使用的这个博客框架下，定义列表支持的不是很好，正常情况下两条<code>:</code>开头的内容应该都是有缩进的。</p>
<p>定义列表的使用场景我个人也没怎么见过，不过在国外网站上倒是见过不少次。个人认为这个语法也能在一定程度上使用无序列表替代，不过这也是仁者见仁智者见智的事（虽然我觉着，其实语义化才应该是主流）。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>算是花了大量的篇幅介绍了md的常用语法，当然，md还有一些语法我还没有介绍到，这个就之后抽时间写了。希望上面的内容能够对各位有所帮助，在学习md时也推荐将代码复制到md编辑器后查看实际效果，这样才能对它的语法有更深入的记忆。</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>Markdown</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3.14更新！同步带来的崭新Python安装方式如何使用？</title>
    <url>/2026/01/01/pymanager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在Python3.14版本更新后，针对Windows平台，一个新的Python版本管理工具也随着更新一同推出，它就是<code>pymanager</code>，这个版本管理工具同时具备Python安装和版本管理功能，相较于Windows上以往的Python安装、管理方式，<code>pymanager</code>无疑是带来了迟到已久的变革。</p>
<p>在<a href="https://www.python.org/downloads/release/python-3142/">Python官方网站</a>的3.14版本的发布页面明确提到这样一句话：</p>
<blockquote>
<p>The installer we offer for Windows is being replaced by our new install manager, which can be installed from the Windows Store or from its download page. See our documentation for more information. The JSON file available for download contains the list of all the installable packages available as part of this release, including file URLs and hashes, but is not required to install the latest release. The traditional installer will remain available throughout the 3.14 and 3.15 releases.</p>
</blockquote>
<p>机翻：</p>
<blockquote>
<p>我们为Windows提供的安装程序将被新的安装管理器取代，安装管理器可以从Windows商店或其下载页面安装。更多信息请参见我们的文档。可下载的 JSON 文件包含了本版本中所有可安装的软件包列表，包括文件 URL 和哈希值，但安装最新版本并非必须的。传统安装程序将在3.14和3.15版本中继续使用。</p>
</blockquote>
<p>也就是说，在未来，以往通过exe直接安装Python具体版本的安装方式将会完全淘汰，无论是出于哪种情况考虑，开发者都迫切需要学会<code>pymanager</code>的基本使用方式。</p>
<p>额外说一句，本人对于这个新的管理工具颇有好感，以往的安装方式是图形化的，它的确方便，但这并不利于培养新手开发者使用命令行的习惯，而<code>pymanager</code>的替代个人认为也有这方面的考虑在。废话就说完了，现在我们进入正题。</p>
<h2 id="安装Pymanager"><a href="#安装Pymanager" class="headerlink" title="安装Pymanager"></a>安装Pymanager</h2><p>在正式介绍安装方法前，我强烈建议你卸载电脑上已有的任何Python安装，并且在此基础上清除Python相关的环境变量，以及删除C:\Windows下的<code>py.exe</code>、<code>pyw.exe</code>两个文件，这一步是可选的，不照做也没有任何影响。</p>
<p>安装Pymanager的方法非常简单，只需要访问<a href="https://www.python.org/downloads/release/pymanager-252/">Python Release Python install manager 25.2</a>页面就行，翻到页面末尾的表格，点击<strong>MSI package</strong>即可下载安装程序。（Installer (MSIX)其实也可以，它只是会捆绑安装一个Python最新正式版而已，考虑到稍后的内容，我并不推荐下载这个。）</p>
<p>下载完成并且找到该文件后（一般是叫python-manager-&lt;version&gt;.msi，比如我在写这篇文章时pymanager的最新版本是25.2，所以文件名就是python-manager-25.2.msi），直接双击安装即可。注意，这个安装程序并不能选择安装位置，整个安装过程自动进行且没有可以干预的环节.</p>
<p><code>pymanager</code>安装程序会在安装时同时向系统变量<code>Path</code>注册自己的位置，也就是说，安装完<code>pymanager</code>后，就可以直接开始使用了。</p>
<h2 id="配置Pymanager"><a href="#配置Pymanager" class="headerlink" title="配置Pymanager"></a>配置Pymanager</h2><p>在上面，我说安装完成后就能直接使用，这是没错的，但如果你像我一样会将不同的东西进行单独分类，比如将各个编程语言的环境放到专门的文件夹进行管理，那么这个部分就能够帮到你。为此，我们先找到<code>pymanager</code>的安装位置，不出意外的话，它应该是位于C:\Program Files\PyManager目录，不必关心里面的大部分文件，我们重点看<code>pymanager.json</code>。</p>
<figure class="highlight json"><figcaption><span>pymanager.json</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;install&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%PYTHON_MANAGER_SOURCE_URL%&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fallback_source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./bundled/fallback-index.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;default_install_tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;format&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%PYTHON_MANAGER_LIST_FORMAT%&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;registry_override_key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HKEY_LOCAL_MACHINE\\Software\\Policies\\Python\\PyManager&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;confirm&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%PYTHON_MANAGER_CONFIRM%&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;automatic_install&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%PYTHON_MANAGER_AUTOMATIC_INSTALL%&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;include_unmanaged&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%PYTHON_MANAGER_INCLUDE_UNMANAGED%&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;virtual_env&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%VIRTUAL_ENV%&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;shebang_can_run_anything&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%PYTHON_MANAGER_SHEBANG_CAN_RUN_ANYTHING%&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;shebang_can_run_anything_silently&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;install_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%LocalAppData%\\Python&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;download_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%LocalAppData%\\Python\\_cache&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;global_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%LocalAppData%\\Python\\bin&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;bundled_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./bundled&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;logs_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%PYTHON_MANAGER_LOGS%&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;default_tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%PYTHON_MANAGER_DEFAULT%&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;default_platform&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%PYTHON_MANAGER_DEFAULT_PLATFORM%&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;user_config&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%AppData%\\Python\\PyManager.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;additional_config&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%PYTHON_MANAGER_CONFIG%&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;pep514_root&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HKEY_CURRENT_USER\\Software\\Python&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;start_folder&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Python&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;launcher_exe&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./templates/launcher.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;launcherw_exe&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./templates/launcherw.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;welcome_on_update&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这个文件是<code>pymanager</code>的配置文件，可以看到，我们能配置的东西还不少，对于我们的需求，需要关注的点是<code>install_dir</code>、<code>download_dir</code>、<code>global_dir</code>以及可选的<code>logs_dir</code>。至于<code>bundled_dir</code>，由于我们一开始就没有选择捆绑安装，所以可以直接将其忽略。</p>
<p>在我的本地环境中，我是将Python单独放在D:\Python目录统一管理的，因此接下来的部分都会使用这个目录，不过你也可以自己决定安装位置，不必跟着我的方案走。我们先来看看这些键分别代表什么（虽然它们的名字足够直观）：</p>
<ul>
<li><strong>install_dir：</strong> 安装目录，也就是实际Python环境安装的目录</li>
<li><strong>download_dir：</strong> 下载目录，安装过程中存放下载缓存的目录</li>
<li><strong>global_dir：</strong> 全局目录，也就是直接执行类似<code>python</code>、<code>python3.13</code>命令时，实际可执行文件的存放目录（注意，这个目录在自定义后需要额外在环境变量配置）</li>
<li><strong>logs_dir：</strong>日志目录……其实我不建议改</li>
</ul>
<p>我们把这三行配置单独拿出来看看，然后根据它的风格，将目录替换成我们自己的目录（注意，我们是修改这三个键值对，而不是让配置文件只剩下这三个键值对；此外，修改时一定要保证有管理员权限）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="attr">&quot;install_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%LocalAppData%\\Python&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;download_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%LocalAppData%\\Python\\_cache&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;global_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%LocalAppData%\\Python\\bin&quot;</span><span class="punctuation">,</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>修改后：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="attr">&quot;install_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Python\\runtimes&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;download_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Python\\_cache&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;global_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Python\\bin&quot;</span><span class="punctuation">,</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>配置完这些，<code>pymanager</code>在安装Python时，就会把文件放在我们配置的目录下了。</p>
<h2 id="安装、管理、运行Python"><a href="#安装、管理、运行Python" class="headerlink" title="安装、管理、运行Python"></a>安装、管理、运行Python</h2><p>接下来，我们来看看如何安装、管理、运行Python</p>
<h3 id="安装（install）"><a href="#安装（install）" class="headerlink" title="安装（install）"></a>安装（install）</h3><p>安装Python基本子命令是<code>install</code>，如果在前面按照我说的，在安装<code>pymanager</code>前删除了相关文件，那么你就能直接使用<code>py</code>命令，否则，请使用<code>pymanager</code>命令：</p>
<figure class="highlight shell"><figcaption><span>安装命令</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意 &lt;&gt;是必传参数 在实际使用命令时这些参数是必须的</span></span><br><span class="line">py install &lt;verison&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">pymanager install &lt;version&gt;</span><br></pre></td></tr></table></figure>

<p>比如，要想安装Python3.14：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">py install 3.14</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">pymanager install 3.14</span><br></pre></td></tr></table></figure>

<p>在安装后，如果有按照上面的小结配置目录，那么查看<code>runtimes</code>目录，你会发现目录下多了一个<code>pythoncore-3.14-64</code>文件夹，其中的目录结构实际上与以往安装时的目录结构是完全一样的。</p>
<p><img src="/2026/01/01/pymanager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/Runtimes.png" alt="Runtimes文件夹（这里有三个版本是因为我自己本身就有安装其他版本）"></p>
<p><img src="/2026/01/01/pymanager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/pythoncore-3.14-64.png" alt="pythoncore-3.14-64文件夹"></p>
<p>在此基础上，<code>pymanager</code>还提供了<code>--update</code>参数，用来升级已有的Python版本，比如，我在写这篇教程时，Python3.13还停留在3.13.8版本，但最新版本却是3.13.11，我们就可以直接在上面的基础上加上这个参数实现升级：</p>
<figure class="highlight shell"><figcaption><span>加上升级参数</span></figcaption><table><tr><td class="code"><pre><span class="line">py install --update 3.13</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">pymanager install --update 3.13</span><br></pre></td></tr></table></figure>

<p>最后，我们都知道从3.13开始，Python软件基金会正在逐步去除全局解释器锁，其发布的Free-threaded通常都是版本后边带t后缀，例如Python3.13t。安装它们也非常简单，只需要在对应的版本后边加上t就行了（以3.14为例）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">py install 3.14t</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">pymanager install 3.14t</span><br></pre></td></tr></table></figure>

<p>由于我本地安装时实际速度较快，因此没有去确定各个镜像源是否有发布<code>pymanager</code>的相关源，实际碰到下载速度问题时，还请优先去找到这些源的官方网站，例如本人常用的<a href="https://mirrors.ustc.edu.cn/help/">中科大镜像源</a>在此附上。</p>
<h3 id="列出（list）和卸载（uninstall）"><a href="#列出（list）和卸载（uninstall）" class="headerlink" title="列出（list）和卸载（uninstall）"></a>列出（list）和卸载（uninstall）</h3><p>每次安装完成后去翻找文件夹确实麻烦，还好<code>pymanager</code>为我们提供了<code>list</code>子命令来列出已安装的版本：</p>
<figure class="highlight shell"><figcaption><span>列出已安装版本命令</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意 []是可选参数 也就是说 实际使用时可以不传入相关参数</span></span><br><span class="line">py list [version]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">pymanager list [version]</span><br></pre></td></tr></table></figure>

<p>我本地安装的是Python3.12、3.13、3.14三个大版本，列出的结果就是这样的：</p>
<p><img src="/2026/01/01/pymanager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/pylist.png" alt="py list命令运行结果"></p>
<p>还是非常直观的，我们在这里可以很方便的看到已安装版本的架构、名称、版本还有别名。当然，<code>list</code>子命令也可以传入一个具体的版本，来列出对应版本的安装，这里我就不演示了。</p>
<p>还记得上面我们安装的3.14t版本吗？现在我们假设我们已经体验完了这个“玩具版本”，不想再留下它了，此时我们就需要卸载它对吧？直接删除对应的文件虽然可以，但不建议，因为<code>pymanager</code>还提供了<code>uninstall</code>子命令，它跟<code>install</code>子命令的使用方法相似：</p>
<figure class="highlight shell"><figcaption><span>卸载命令</span></figcaption><table><tr><td class="code"><pre><span class="line">py uninstall &lt;version&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">pymanager uninstall &lt;version&gt;</span><br></pre></td></tr></table></figure>

<p>那么要想卸载3.14t，就是这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">py uninstall 3.14t</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">pymanager uninstall 3.14t</span><br></pre></td></tr></table></figure>

<p>执行命令后，会在卸载前询问是否确认，输入y便可，卸载后我们用<code>list</code>检查一下：</p>
<p><img src="/2026/01/01/pymanager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/pylist2.png" alt="卸载后重新运行py list命令"></p>
<p>可以看到，3.14t在卸载后，也从列表中消失了。</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><code>py</code>和<code>pymanager</code>命令实际上存在一些差别，但别着急，我们稍后来讨论这个问题。现在，我们来直接运行一下<code>py</code>（或者<code>pymanager exec</code>）命令，不出意外的话，你应该能跟我一样打开熟悉的Python交互式解释器（版本可能不太相同）：</p>
<p><img src="/2026/01/01/pymanager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/pyconsole.png" alt="Python Console"></p>
<p>可以看到，<code>pymanager</code>默认使用最新版本，但如果想使用指定版本，例如3.12，又该怎么办呢？</p>
<figure class="highlight shell"><figcaption><span>打开指定版本的Python交互式解释器</span></figcaption><table><tr><td class="code"><pre><span class="line">py -V:&lt;version&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">pymanager exec -V:&lt;version&gt;</span><br></pre></td></tr></table></figure>

<p><code>-V:</code>参数（注意大小写，这里是大写）可以指定一个已安装版本，例如上面，我们想运行3.12版本就该这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">py -V:3.12</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">pymanager exec -V:3.12</span><br></pre></td></tr></table></figure>

<p>我们便成功打开了指定版本的Python交互式解释器：</p>
<p><img src="/2026/01/01/pymanager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/py3.12_console.png" alt="Python3.12 Console"></p>
<p>在使用对应解释器的<code>pip</code>、<code>venv</code>等内置命令时，就能在此基础上，像以往直接使用<code>python</code>命令一样使用<code>-m</code>参数：</p>
<figure class="highlight shell"><figcaption><span>加上-m参数</span></figcaption><table><tr><td class="code"><pre><span class="line">py -m pip ... # 使用默认版本</span><br><span class="line"></span><br><span class="line">py -V:&lt;version&gt; -m pip ...</span><br><span class="line">py -V:&lt;version&gt; -m venv ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line"></span><br><span class="line">pymanager exec -m pip ... # 使用默认版本</span><br><span class="line"></span><br><span class="line">pymanager exec -V:&lt;version&gt; -m pip ...</span><br><span class="line">pymanager exec -V:&lt;version&gt; -m venv ...</span><br></pre></td></tr></table></figure>

<p>当然，直接运行脚本也是如此，现在我们<strong>假设</strong>要运行的文件是当前目录下的<code>main.py</code>：</p>
<figure class="highlight shell"><figcaption><span>直接运行脚本</span></figcaption><table><tr><td class="code"><pre><span class="line">py ./main.py # 使用默认版本</span><br><span class="line">py -V:&lt;version&gt; ./main.py</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line"></span><br><span class="line">pymanager exec ./main.py # 使用默认版本</span><br><span class="line">pymanager exec -V:&lt;version&gt; ./main.py</span><br></pre></td></tr></table></figure>

<p>注意，如果你以前习惯使用<code>py -3.13</code>这样的参数风格，可能需要习惯一段时间，这里只需要记住：在原来的基础上加上<code>V:</code>即可，例如这里就是<code>py -V:3.13</code>。</p>
<h2 id="运行Python"><a href="#运行Python" class="headerlink" title="运行Python"></a>运行Python</h2><p>上面我们已经介绍了如何<a href="#%E8%BF%90%E8%A1%8C">运行Python</a>，你可能会问：为什么这里还要单独列出一个<strong>运行Python</strong>的章节呢？实际上，运行Python的内容远不止上面提到的，我们接下来要介绍的内容，就是有关脚本文件的运行。</p>
<h3 id="设置文件的默认打开方式"><a href="#设置文件的默认打开方式" class="headerlink" title="设置文件的默认打开方式"></a>设置文件的默认打开方式</h3><p>在上面，我们都是基于命令行执行的操作，但也许大部分人在Windows上都更习惯直接双击运行某个Python文件，那么我们先来解决双击运行的问题，随便在什么地方创建两个Python脚本文件，分别以<code>.py</code>、<code>.pyw</code>作为拓展名（里面可以什么都没有，重点是设置打开方式）：</p>
<p><img src="/2026/01/01/pymanager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/pyfile.png" alt="Python文件"></p>
<p>由于我在很久之前就已经设置好了打开方式，因此这里<code>.py</code>文件的图标是正常的，但<code>.pyw</code>文件图标是缺失的，第一次安装Python的情况下，缺失图标才是正常现象，我们来分别设置一下打开方式，先来右键<code>.py</code>文件，点击“打开方式&gt;选择其他应用”：</p>
<p><img src="/2026/01/01/pymanager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/setopenapp_1.png" alt="设置打开方式"></p>
<p>在新的窗口，滚到最下面，点击“在电脑上选择应用”：</p>
<p><img src="/2026/01/01/pymanager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/setopenapp_2.png" alt="选择应用程序"></p>
<p>接着，找到<code>pymanager</code>的安装位置，我们之前提到过的（C:\Program Files\PyManager），这里的重点是选择<code>python.exe</code>文件：</p>
<p><img src="/2026/01/01/pymanager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/openfile.png" alt="打开文件"></p>
<p>最后，点击“始终”：</p>
<p><img src="/2026/01/01/pymanager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/Yes_1.png" alt="确认设置"></p>
<p>如法炮制，我们来设置<code>.pyw</code>的打开方式，步骤基本不变，但在选择应用程序的步骤，我们这次选择<code>pythonw.exe</code>文件：</p>
<p><img src="/2026/01/01/pymanager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/openfile_w.png" alt="打开文件"></p>
<p>同样点击“始终”后，你的文件图标大概就变得跟我一样了：</p>
<p><img src="/2026/01/01/pymanager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/pyfile_over.png" alt="设置完成"></p>
<p>图标没变的话也不需要担心，因为我们要检查的重点是文件是否真的是以我们指定的方式打开的，为此不妨将这段代码放到文件里，然后直接双击打开看看（该代码来自于<a href="https://docs.python.org/zh-cn/3/library/tkinter.html#a-hello-world-program">Python官方文档 - tkinter</a>）：</p>
<figure class="highlight python"><figcaption><span>Tkinter版Hello_World</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> ttk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">frm = ttk.Frame(root, padding=<span class="number">10</span>)</span><br><span class="line">frm.grid()</span><br><span class="line">ttk.Label(frm, text=<span class="string">&quot;Hello World!&quot;</span>).grid(column=<span class="number">0</span>, row=<span class="number">0</span>)</span><br><span class="line">ttk.Button(frm, text=<span class="string">&quot;Quit&quot;</span>, command=root.destroy).grid(column=<span class="number">1</span>, row=<span class="number">0</span>)</span><br><span class="line">root.mainloop()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我的本地环境是将终端设置为了半透明模式的，此前展示的控制台实际上是VSCode自己的控制台，因此不要担心打开的“黑窗口”跟我不一样，我们要查看的重点是那个小窗口，下面是双击<code>.py</code>和<code>.pyw</code>文件后，二者的实际效果：</p>
<p><img src="/2026/01/01/pymanager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/window_nw.png" alt="run.py运行结果"></p>
<p><img src="/2026/01/01/pymanager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/window_w.png" alt="run.pyw运行结果"></p>
<p>如果双击文件后直接就显示了窗口，说明你成功了。</p>
<h3 id="在脚本中指定Python版本"><a href="#在脚本中指定Python版本" class="headerlink" title="在脚本中指定Python版本"></a>在脚本中指定Python版本</h3><p>在上面，我们都是通过<code>-V:&lt;version&gt;</code>参数来指定运行版本的，但这样做未免有些麻烦，正式讲解内容前，请随便创建一个新的Python文件（我们是要通过控制台输出，从而验证版本，所以请使用<code>.py</code>拓展名），将以下代码复制到你的文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> version</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(version)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>做完这一步，我们就可以来了解一下<code>Shebang</code>行了，我们来看看<a href="https://docs.python.org/zh-cn/3.15/using/windows.html#shebang-lines">官方文档</a>中的描述：</p>
<blockquote>
<p>如果脚本文件的第一行以 <code>#!</code> 开头，则称为 “shebang” 行。Linux 和其他类 Unix 操作系统对这类行有原生支持，通常用于指示脚本的执行方式。 <code>python</code> 和 <code>py</code> 命令允许在 Windows 上的 Python 脚本中使用相同的功能。</p>
</blockquote>
<p>这时我们便能明了PyManager目录下<code>pymanager</code>、<code>py</code>和<code>python</code>三个可执行文件分别是用来干什么的了（当然，这也包括对应的<code>pywmanager</code>、<code>pyw</code>和<code>pythonw</code>三个隐藏控制台的版本）</p>
<ul>
<li><strong>pymanager &amp; pywmanager：</strong> 专门用来管理Python环境的安装、卸载</li>
<li><strong>py &amp; pyw：</strong> 除了拥有pymanager的所有功能，还能直接根据参数、Shebang行自动选择合适的Python版本</li>
<li><strong>python &amp; pythonw：</strong> 跟<code>py</code>命令一样，不过这个命令通常会被实际的默认版本的Python Alias覆盖，因此通常不会用它</li>
</ul>
<p>也许刚刚你就在好奇，为什么唯独<strong>运行</strong>小结会单独在<code>pymanager</code>命令后边额外使用<code>exec</code>子命令，实际上就是因为<code>pymanager</code>并不能直接执行脚本。在<code>py</code>命令存在冲突，不得不使用<code>pymanager</code>时，还请注意这一点。</p>
<p>说回Shebang行，也许你已经注意到，上面的源码中存在一个空的Shebang行，这就是我们接下来要修改的地方了，不过我们先来看看实际支持的所谓“虚拟”命令：</p>
<ul>
<li><code>/usr/bin/env &lt;ALIAS&gt;</code></li>
<li><code>/usr/bin/env -S &lt;ALIAS&gt;</code></li>
<li><code>/usr/bin/&lt;ALIAS&gt;</code></li>
<li><code>/usr/local/bin/&lt;ALIAS&gt;</code></li>
<li><code>&lt;ALIAS&gt;</code></li>
</ul>
<p>除了最后的<code>python</code>，剩下三个我想长期使用Linux的用户已经觉得眼熟了，这是正常的，<a href="https://docs.python.org/zh-cn/3.15/using/windows.html#shebang-lines">因为</a>：</p>
<blockquote>
<p>为了允许Python脚本中的shebang行在Unix和Windows之间移植，该启动器支持许多“虚拟”命令来指定要使用的解释器。</p>
</blockquote>
<p>还挺周到不是吗？那我们来实际试试：让上面的代码以3.13版本运行，预期的打印应当是类似于这个输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3.13.11 (tags/v3.13.11:6278944, Dec  5 2025, 16:26:58) [MSC v.1944 64 bit (AMD64)]</span><br></pre></td></tr></table></figure>

<p>将刚刚代码的空Shebang行改成这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3.13</span></span><br></pre></td></tr></table></figure>

<p>然后运行：</p>
<p><img src="/2026/01/01/pymanager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/run1.png" alt="运行结果"></p>
<p>输出果然符合预期，注意，如果你不知道<code>&lt;ALIAS&gt;</code>具体替换成什么，请直接通过<code>py list</code>命令查看Alias列（实际写的时候像我上面那样忽略掉拓展名和[x64]）。</p>
<p>有关<code>env</code>系列的虚拟命令，由于我没怎么接触过Linux开发，就只能贴上<a href="https://docs.python.org/zh-cn/3.15/using/windows.html#shebang-lines">官方文档</a>的描述了：</p>
<blockquote>
<p>使用 <code>/usr/bin/env</code> 形式的 shebang 行也会在 <code>PATH</code> 环境变量中搜索未识别的命令。这与 Unix 的<code>env</code>程序的行为相对应，该程序执行相同的搜索，但优先启动已知的 Python 命令。在搜索任意可执行文件时可能会显示警告，并且可以通过 <code>shebang_can_run_anything</code> 配置选项禁用此搜索。</p>
</blockquote>
<h3 id="以指定的虚拟环境运行脚本"><a href="#以指定的虚拟环境运行脚本" class="headerlink" title="以指定的虚拟环境运行脚本"></a>以指定的虚拟环境运行脚本</h3><p>在旧的py命令下，实际上可以直接指定虚拟环境的python可执行文件位置，来让脚本以对应的虚拟环境运行，但<code>pymanager</code>并不能直接指定，其中可能的一个原因，估计就是它跟以前一样，会优先选择已经激活的虚拟环境运行脚本。</p>
<p>我们来验证这一点，为此，请用你熟悉的虚拟环境创建工具来创建新的虚拟环境，以3.12版本为例，我个人通常用<code>venv</code>（这里就不罗列对应的<code>pymanager</code>命令了）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">py -V:3.12 -m venv env</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后激活虚拟环境</span></span><br><span class="line">.\env\Scripts\activate</span><br></pre></td></tr></table></figure>

<p>创建一个新的Python文件（同样是<code>.py</code>），将以下代码直接复制到文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> executable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(executable)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，去掉Shebang行，直接执行之前创建好的Python文件，上面的代码会打印出当前所使用解释器的路径，如果激活了虚拟环境，它应该是打印虚拟环境的解释器路径，没有的话，它就是打印默认使用的（或者你指定的）Python版本对应的全局安装路径。</p>
<p>注意，Shebang行、虚拟环境（下面简写为ENV）和<code>-V:&lt;version&gt;</code>（下面简写为<code>-V</code>）存在如下的优先级关系：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">-V &gt; Shebang &gt; ENV</span><br></pre></td></tr></table></figure>

<p>也就是说，直接指定的Python版本优先于Shebang行指定的版本，Shebang行指定的版本优先于当前已经激活的虚拟环境，在实际运行脚本时，一定要特别注意这一点。</p>
<p>实际上，在<a href="https://docs.python.org/zh-cn/3.15/using/windows.html#shebang-lines">官方文档</a>中存在这样的描述：</p>
<blockquote>
<p>不符合上述任何模式的 shebang 行将被视为相对于脚本文件所在目录的 Windows 可执行文件路径（绝对或相对路径）。这为仅限 Windows 的脚本（如安装程序生成的脚本）提供了便利，因为这种行为与 Unix 风格的 shell 不兼容。这些路径可以加引号，并且可以包含多个参数，之后会追加脚本路径和任何额外的参数。此功能可以通过 <code>shebang_can_run_anything</code> 配置选项禁用。</p>
</blockquote>
<p>看起来Shebang行至少在设计上应该是支持类似<code>./env/Scripts/python.exe</code>的写法的，但我在实际测试发现并不可行，在没有匹配之前提到的“虚拟命令”，且当前没有激活虚拟环境时，<code>py</code>似乎会选择全局默认版本来运行脚本，尚不确定这是什么情况。</p>
<h2 id="留到最后"><a href="#留到最后" class="headerlink" title="留到最后"></a>留到最后</h2><p>由于这篇博客只是为了简单介绍<code>pymanager</code>的使用方法，其内容定然没有官方文档来的详细，链接我似乎在这篇博客里提到了多次，还请原谅我在这里最后一次贴出官方文档的链接，更多内容还请移步到这里：<a href="https://docs.python.org/zh-cn/3.15/using/windows.html#python-install-manager">Python 安装管理器</a>。</p>
<p>同时，最近一段时间，Python官方网站设置了一个横幅，那个是捐赠的入口，额……自打Python的核心开发者们被微软辞退后，基金会的现状似乎也不容乐观呢……</p>
<blockquote>
<p>Banners are cringe,<br>but so is unfunded software development and security 😅<br>Please keep reading:</p>
<p>As the Python Software Foundation (PSF) closes out 2025, we humbly ask you to reflect on how Python has impacted your life, what value it provided you, and whether you’re able to give $10 back. The PSF is the charity supporting the Python community and protecting the Python programming language, ensuring it stays free, forever, for everyone.</p>
<p>If Python has provided at least $10 of value to you in the past year, please help by donating now–your support really makes all the difference. Thank you for your time and generosity!</p>
</blockquote>
<p>机翻：</p>
<blockquote>
<p>横幅真让人尴尬，<br>但无资金的软件开发和安全😅同样重要，<br>请继续阅读：</p>
<p>随着Python软件基金会（PSF）即将结束2025年，我们谦逊地邀请您反思Python如何影响了您的生活，它为您带来了哪些价值，以及您是否能够回馈10美元。PSF是支持Python社区、保护Python编程语言的慈善机构，确保它永远免费，惠及所有人。</p>
<p>如果过去一年Python至少为你提供了10美元的价值，请现在就捐款——你的支持真的能带来巨大改变。感谢您的时间和慷慨！</p>
</blockquote>
<p>在此，我也呼吁看到这里的朋友能在自己经济能力允许的情况下，支持一下Python软件基金会，正如横幅所说的，我们的支持真的能带来巨大的改变（）</p>
<p>最后，非常感谢能看到这里，一如既往的希望我的内容能帮到阅读我博客的你~</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>教程</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>让你的Python代码更具可读性——类型标注</title>
    <url>/2024/09/17/Python%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8/</url>
    <content><![CDATA[<p>你是否有这样的困扰：</p>
<ul>
<li>代码量到达一定数量级后，很难记住自己编写的函数应该传入什么类型的参数</li>
<li>陈年代码即使代码命名规范，也弄不清楚一个函数究竟返回的什么值</li>
<li>同事（合作者）很难理解你写的函数（或者类）在对什么类型的数据做什么样的操作，返回了什么类型的数据</li>
<li>等等……</li>
</ul>
<p>如果您恰好有这些（或类似）的困扰，又在现阶段没什么解决方案的话，Python的类型标注语法便是您的一个不错的选择。</p>
<p>Python类型标注语法从3.5版本开始引入，在此之前的版本并不能支持这个语法，因此在使用类型标注时请注意这个前提。现在我们就开始正式内容吧。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>让我们先直接看看下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">list_print</span>(<span class="params">target</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> target:</span><br><span class="line">        <span class="built_in">print</span>(i, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_number</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">temp = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>]</span><br><span class="line">list_print(temp)</span><br><span class="line"></span><br><span class="line">temp1 = add_number(<span class="number">2</span>, <span class="number">3.14</span>)</span><br></pre></td></tr></table></figure>

<p>上面的代码是我随便写的，它们的功能也挺简单的，让人一眼就能看出两个函数究竟在干什么事。不过……我们来看看<code>add_number()</code>这个函数，虽然我们的确可以看出它是对两个数进行求和，但是在Python中，字符串同样可以通过<code>+</code>相连接，换句话说这个函数在传入字符串时也能够正常工作。还有一个问题是参数混合传入的问题，如果调用者传入了一个int类型的数据和一个str类型的数据，那么这个函数一定是不能正常工作的，在这种情况下，一个直觉上的做法是做类型检查：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.11</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_number</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">assert</span> [(a, b) <span class="keyword">for</span> t <span class="keyword">in</span> (<span class="built_in">int</span>, <span class="built_in">float</span>) <span class="keyword">if</span> <span class="built_in">type</span>(a) <span class="keyword">is</span> t <span class="keyword">and</span> b <span class="keyword">is</span> t], <span class="string">&quot;Unsupported types&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在这里，我们在代码中添加了一句断言来判断两个参数的类型是否为<code>int</code>或者<code>float</code>，在发现类型不属于这两种类型时，函数便会终止执行并抛出一个<code>AssertionError</code>。这样的解决方案固然是好事，不过我们实际上也更希望在编写时就不要出现这种错误，为此，我们可以改成这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.11</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_number</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">assert</span> [(a, b) <span class="keyword">for</span> t <span class="keyword">in</span> (<span class="built_in">int</span>, <span class="built_in">float</span>) <span class="keyword">if</span> <span class="built_in">type</span>(a) <span class="keyword">is</span> t <span class="keyword">and</span> b <span class="keyword">is</span> t], <span class="string">&quot;Unsupported types&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在上面的基础上，我在每个参数后面加上了<code>: [type]</code>，在函数的最后加上了<code>-&gt; [type]</code>，这就是最基础的类型标注语法，通过冒号来注明变量的类型，通过<code>-&gt;</code>来注明函数的返回值。那么基于这个知识点，最开始的代码我们就可以修改成这样(我们先假设<code>list_print()</code>函数只接受<code>list</code>)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">list_print</span>(<span class="params">target:<span class="built_in">list</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> target:</span><br><span class="line">        <span class="built_in">print</span>(i, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_number</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">assert</span> [(a, b) <span class="keyword">for</span> t <span class="keyword">in</span> (<span class="built_in">int</span>, <span class="built_in">float</span>) <span class="keyword">if</span> <span class="built_in">type</span>(a) <span class="keyword">is</span> t <span class="keyword">and</span> b <span class="keyword">is</span> t], <span class="string">&quot;Unsupported types&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">temp: <span class="built_in">list</span> = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>]</span><br><span class="line">list_print(temp)</span><br><span class="line"></span><br><span class="line">temp1: <span class="built_in">int</span> = add_number(<span class="number">2</span>, <span class="number">3.14</span>)</span><br></pre></td></tr></table></figure>

<p>这里为了更好的演示类型标注，我为两个变量<code>temp</code>、<code>temp1</code>也做了类型标注。在这里，由于<code>list_number()</code>并没有返回值，因此我们为这个函数加上的返回值标注为<code>-&gt; None</code>，表明这个函数并不返回任何东西。一套最基础的类型标注就这样写好了。值得注意的是，诸如<code>int</code>、<code>list</code>等内置类型的类名实际上可以直接作为类型标注的一部分写进去，而无需顾虑它们是否会出现语法错误……吗？在这里我是基于3.11版本的Python做的类型标注，关于不同版本的变化，我们待会儿就会提到。</p>
<p>不过也许您已经发现了，<code>add_number()</code>在设计上也能够接收<code>float</code>作为参数，但我们的类型标注并没有反映这一点，为此我们需要引入一个新的符号：<code>|</code>。这个符号我想各位应该再熟悉不过了，它在类型标注里面的用法也非常简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_number</span>(<span class="params">a: <span class="built_in">int</span> | <span class="built_in">float</span>, b: <span class="built_in">int</span> | <span class="built_in">float</span></span>) -&gt; <span class="built_in">int</span> | <span class="built_in">float</span>:</span><br><span class="line">    <span class="keyword">assert</span> [(a, b) <span class="keyword">for</span> t <span class="keyword">in</span> (<span class="built_in">int</span>, <span class="built_in">float</span>) <span class="keyword">if</span> <span class="built_in">type</span>(a) <span class="keyword">is</span> t <span class="keyword">and</span> b <span class="keyword">is</span> t], <span class="string">&quot;Unsupported types&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>只需要用<code>|</code>分割两个及以上的类型，便能表示一个对象支持多种不同的类型，这个语法只在3.10及以上的版本有效。</p>
<p>截至到此，这个函数现在已经不足以支持更多的功能了，现在，让我们来把这个函数的功能扩充一下，并且换个新的名字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_number</span>(<span class="params">target_list: <span class="built_in">list</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;简单实现的一个判断列表内所有元素是否都是支持类型的函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(target_list) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> target_list:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(i, <span class="built_in">int</span>) <span class="keyword">or</span> <span class="built_in">isinstance</span>(i, <span class="built_in">float</span>):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">target: <span class="built_in">list</span></span>) -&gt; <span class="built_in">int</span> | <span class="built_in">float</span>:</span><br><span class="line">    <span class="keyword">assert</span> is_number(target)</span><br><span class="line"></span><br><span class="line">    temp = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> target:</span><br><span class="line">        temp += i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> temp</span><br></pre></td></tr></table></figure>

<p>这个名为<code>sum()</code>的函数接受一个列表作为参数，目的也是非常简单直接的对数据进行求和，函数里面我们使用了断言判断列表内是否有不支持的类型。对于这种需要列表中只能存在特定类型的情况，类型标注也能很好的应对（这里就只写函数定义了）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">target: <span class="built_in">list</span>[<span class="built_in">int</span> | <span class="built_in">float</span>]</span>): ...</span><br></pre></td></tr></table></figure>

<p>通过在支持的类型后面加上<code>[]</code>，然后在其中列出类型（用<code>|</code>隔开），就能很好的表示这个函数接受的列表（上面的例子）中只能是<code>int</code>或者<code>float</code>类型。</p>
<p>对于<code>dict</code>这种类型，我们也可以分别为键和值设定类型，就像这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_dict</span>(<span class="params">target: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span> | <span class="built_in">float</span>]</span>) -&gt; <span class="literal">None</span>: ...</span><br></pre></td></tr></table></figure>

<p>类似于<code>dict</code>的类型比如Map，我们都可以用type[key_type, value_type]来进行标注，而且里面还支持嵌入其它类型标注语法来实现更加复杂的标注。那么这里的标注就表明这个参数接受的是<code>key</code>为<code>str</code>、<code>value</code>为<code>int</code>或者<code>float</code>的字典。</p>
<p>当然，针对list这样的序列类型，这样的写法是错误的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.11</span></span><br><span class="line"></span><br><span class="line">a: <span class="built_in">list</span>[<span class="built_in">int</span>, <span class="built_in">float</span>] = [<span class="number">3.14</span>, <span class="number">6</span>] <span class="comment"># 错误的类型标注写法</span></span><br></pre></td></tr></table></figure>

<p>类似list这样的类型的类型标注都只接受一个类型参数，因此上面的写法自然会导致静态类型检查器抛出错误。不过tuple是个例外：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a: <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">str</span>] = (<span class="number">20</span>, <span class="string">&quot;a&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在这里，这个类型标注表示元组的第一个元素是<code>int</code>类型，第二个是<code>str</code>类型。那么长度不定又该怎么办呢……</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.11</span></span><br><span class="line"></span><br><span class="line">a: <span class="built_in">tuple</span>[<span class="built_in">int</span> | <span class="built_in">float</span>, ...] = [<span class="number">3.14</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<p>使用三个点便能很好的表达“长度不定”的含义，上面的类型标注的解释自然就是一个内部元素为<code>int</code>或者<code>float</code>的、长度不确定的元组了，请注意，三点只能作为类型参数的第二个参数。</p>
<p>现在回到一般化的情况，要想表示一个空的序列，那么只需要把方括号里面的内容直接换成<code>()</code>就好了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.11</span></span><br><span class="line"></span><br><span class="line">a: <span class="built_in">list</span>[()] = [] <span class="comment"># 空列表</span></span><br><span class="line">b: <span class="built_in">tuple</span>[()] = () <span class="comment"># 空元组</span></span><br></pre></td></tr></table></figure>

<p>上面的内容便是基础类型标注的所有内容了，现在让我们稍微综合一下上面的内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseSprite</span>: ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fight</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, global_buff_list: <span class="built_in">list</span>[<span class="string">&quot;Buff&quot;</span>], pa: <span class="built_in">list</span>[BaseSprite], pb: <span class="built_in">list</span>[BaseSprite]</span>) -&gt; <span class="literal">None</span>: ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_buff</span>(<span class="params">self, target_buff: <span class="string">&quot;Buff&quot;</span></span>) -&gt; <span class="literal">None</span>: ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>() -&gt; <span class="literal">None</span>: ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buff</span>:</span><br><span class="line">    name: <span class="built_in">str</span></span><br></pre></td></tr></table></figure>

<p>这里我们简单实现了一个战斗事件处理的类（当然，这里为了省事没有写很完整的源代码），并且加上了上面提到的大部分类型标注语法。这里有一个上面漏掉的细节，那就是如果一个类型<strong>在标注前并没有被定义</strong>，那么可以用双引号包裹来表示这个类型会在其之后创建。</p>
<p>基础的标注语法就这样差不多了，下面我们开始来点进阶的东西。</p>
<h2 id="typing"><a href="#typing" class="headerlink" title="typing"></a>typing</h2><p>typing是Python3.5版本引入的一个用于支持类型标注的模块，这个模块无需额外安装便可直接import到脚本中使用（当然，肯定不支持3.5以下的Python版本）。由于Python的类型标注语法是渐进式的加入到Python中并逐渐完善的，因此在每个版本中typing总是承担了一定的过渡性作用，一部分在某个版本不能使用的高版本类型注释语法就需要通过typing来编写。我们先不提typing作为低版本类型注释兼容的功能，来看看typing的一些普通用法。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在一些情况下，我们需求的类型可能是一些有着相似功能的好几个甚至好几十个类型，例如具有序列（Sequence）功能的list、tuple和set，又或者都属于数字（number）的int和float，以及一些第三方库定义的类别。针对这些情况，第三方库固然可以通过标注其父类来解决这个问题，但是内置类型就得借助typing来解决了。还记得我们的<code>list_print()</code>函数吗？现在我们来修改一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Sequence</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sequence_print</span>(<span class="params">target: <span class="type">Sequence</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> target:</span><br><span class="line">        <span class="built_in">print</span>(i, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>Sequence</code>即序列，常见的list、tuple都属于这个范畴，通过一个Sequence我们就不必傻乎乎的用<code>list | tuple</code>这种写法了，是不是很方便？</p>
<p>当然，我们肯定也会碰到一个函数的某个参数支持所有类型的情况，或者干脆就是我并不知道一个函数会返回什么类型，这个时候便可以用Any来进行标注：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">any_function</span>(<span class="params">obj: <span class="type">Any</span></span>) -&gt; <span class="type">Any</span>: ... <span class="comment"># 这里的函数命名不要在意（</span></span><br></pre></td></tr></table></figure>

<p>除了上面这些，typing里面还有许多其他的抽象类可以使用，详情请查阅<a href="https://docs.python.org/zh-cn/3/library/typing.html">Python官方文档</a>，在这里很多与类型标注相关的功能都会有所介绍。</p>
<h3 id="更清晰的表达"><a href="#更清晰的表达" class="headerlink" title="更清晰的表达"></a>更清晰的表达</h3><p>类型标注的存在意义便是增强代码可读性，typing中定义了一些能够帮助我们更加清晰表达的类和字段，来帮助我们更好的进行类型标注。在这里我们就来看看几个比较常用的。</p>
<p>第一个场景，还记得之前我们对函数标注的<code>-&gt; None</code>吗？这个实际上可以有两个理解：</p>
<ul>
<li>函数是真的返回None值</li>
<li>函数没有返回值</li>
</ul>
<p>针对这种模糊不清的表达，typing提供了一个处理<strong>没有返回值</strong>情况的类<code>NoReturn</code>来更加直接的表达这个含义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> NoReturn</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">useless_function</span>() -&gt; NoReturn: ... <span class="comment"># 一个和它名字一样没什么用的函数</span></span><br></pre></td></tr></table></figure>

<p>第二个场景，一个函数会出现返回某个类型的值<strong>或者None</strong>的情况，也许你会下意识的想到用<code>[type] | None</code>，这样的写法确实挺好的，不过既然连单独没有返回值的情况都能有个<code>NoReturn</code>来表示了，那么这里的None我们是否也有办法省略呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_add</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[<span class="built_in">int</span>]: ...</span><br></pre></td></tr></table></figure>

<p><code>Optional</code>在typing中的文档字符串为“Optional[X] is equivalent to Union[X, None].”，也就是说，Optional[type]就代表了type或者None，通过使用它，我们便又一次省下了一种稍微麻烦的写法。</p>
<p>最后，在类的<code>__init__(self)</code>函数中，第一个参数代表对象本身，这个self是否也能对它进行标注呢？还有一个场景是，我们定义的某个方法需要返回对象自己，这又该如何表示呢？我们来看看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> NoReturn</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Alice</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self: <span class="string">&quot;Alice&quot;</span>, name: <span class="built_in">str</span></span>) -&gt; NoReturn: ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">copy</span>() -&gt; <span class="string">&quot;Alice&quot;</span>: ...</span><br></pre></td></tr></table></figure>

<p>这个写法就是我们在基础语法小节介绍的使用字符串包裹之后才会定义的类型的字段的技巧，这种标注肯定是没问题的但……不可能每个类我都得这样进行标注吧，有没有什么更简单、更通用的标注呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> NoReturn</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Self</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Alice</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self: Self, name: <span class="built_in">str</span></span>) -&gt; NoReturn: ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">copy</span>() -&gt; Self: ...</span><br></pre></td></tr></table></figure>

<p><code>Self</code>我想无需过多解释，这个字段用于表示对象自身，有了这个字段，便可以不用傻乎乎的使用字符串包裹未定义类型名的方式来标明传入或返回自身的情况了。</p>
<h2 id="类型标注兼容"><a href="#类型标注兼容" class="headerlink" title="类型标注兼容"></a>类型标注兼容</h2><p>还记得我们提到的typing低版本兼容的作用吗？在前面我们提过，Python的类型标注是渐进式的添加到Python中的，因此不同时期Python版本的类型标注语法也不尽相同，例如使用<code>|</code>分割类型的语法就是3.10才开始支持的。</p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>由于我在写这篇博客时是使用的3.11版本的Python来测试类型标注，因此实际上我还有一个3.12的语法没有提到，这里索性就直接说了。在3.12，我们可以通过<code>type</code>语句来定义一个类型别名，就像这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.12</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> NumberList = <span class="built_in">list</span>[<span class="built_in">int</span> | <span class="built_in">float</span>]</span><br></pre></td></tr></table></figure>

<p>如果是使用低版本，我们也可以通过typing模块的<code>TypeAlias</code>类型，来显式的表明一个常规的变量定义实际上是定义类型别名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.11</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeAlias</span><br><span class="line"></span><br><span class="line">NumberList: TypeAlias = <span class="built_in">list</span>[<span class="built_in">int</span> | <span class="built_in">float</span>]</span><br></pre></td></tr></table></figure>

<h3 id="多类型语法"><a href="#多类型语法" class="headerlink" title="多类型语法"></a>多类型语法</h3><p>在3.10以下的Python中，使用竖线分割多个类型并不被支持，对于这种情况，我们需要使用<code>Union</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类型标注等价于`int | float`</span></span><br><span class="line">temp: <span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">float</span>] = <span class="number">3.14</span></span><br></pre></td></tr></table></figure>

<p>同样的，3.10以下版本的内置类型的名字<code>list</code>等并不支持类似<code>list[]</code>的语法，因此我们需要额外引入对应的typing类型替代：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!python3.9</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span> <span class="comment"># 以list为例</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类型标注等价于list[int | float]</span></span><br><span class="line">temp: <span class="type">List</span>[<span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">float</span>]] = [<span class="number">3.14</span>, <span class="number">89</span>]</span><br></pre></td></tr></table></figure>

<p>通过import对应类型的首字母大写的类型名，便可让我们编写与之相对应的类型标注。</p>
<p>有关更多类型标注相关的内容，还请参阅相关的<a href="https://docs.python.org/zh-cn/3/library/typing.html">Python官方文档</a>，由于我平常可以拿来写博客的时间并不多，因此博客的内容肯定是不如官方文档全面甚至有可能会犯一些现阶段还没找到的错误的。</p>
<h2 id="结语和参考"><a href="#结语和参考" class="headerlink" title="结语和参考"></a>结语和参考</h2><p>有关Python类型标注语法的介绍就到这里结束了，这篇博客只提到了一些本人认为常用且基础的部分，并不能涵盖所有的可能的应用场景，因此各位在实际使用时也应当多去参阅官方文档。</p>
<p>参考文献：</p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3/library/typing.html">typing —— 对类型提示的支持 — Python 3.12.6 文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>教程</tag>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
